import 'dart:developer';
import 'package:excel/excel.dart';
import 'package:excel_file/excel_service.dart';
import 'package:flutter/foundation.dart'; // for compute
import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Excel Import',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      home: const MyHomePage(title: 'Import Excel File'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});

  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  bool isLoading = false;
  ExcelFileRepository? excelRepository;

  // Instead of storing an Excel instance directly, you could also store a serializable structure
  // For demonstration, we keep the Excel object (ensure it can be used safely across isolates)
  Map<String, dynamic>? importedData;

  Future<void> _importExcelFile() async {
    setState(() {
      isLoading = true;
    });

    final data = await importData();

    setState(() {
      importedData = data;
      isLoading = false;
    });

    if (data != null) {
      data.forEach(
        (key, value) {
          log('key: $key value: $value', name: "importedData");
        },
      );
    } else {
      log('No file was imported.');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            if (isLoading) const CircularProgressIndicator(),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: isLoading ? null : _importExcelFile,
              child: const Text('Import Excel File'),
            ),
            const SizedBox(height: 20),
            if (importedData != null)
              Text('Imported: ${importedData!.keys.firstOrNull}',
                  style: const TextStyle(fontSize: 16)),
          ],
        ),
      ),
    );
  }

  Future<Map<String, dynamic>?> importData() async {
    final filePickerResult = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['xlsx', 'xls'],
      withReadStream: true,
      withData: true,
    );

    if (filePickerResult == null || filePickerResult.files.isEmpty) return null;
    final Map<String, dynamic> map = {};

    for (final file in filePickerResult.files) {
      final fileName = file.name;
      // Retrieve the bytes from the file picker (this works on web since withData:true is set)
      // final bytes = await file.readStream?.single;
      // if (bytes == null) continue;
      log('File name: $fileName, Extension: ${file.extension}, Bytes: {bytes.length}',
          name: 'filePickerResult');

      // Use compute to decode the Excel file on a background isolate
      try {
        log('assign worker', name: "importData");
        // Instantiate the worker generated by Squadron.
        excelRepository = ExcelFileRepositoryWorker();
        final data = await file.readStream!.single;

        // final excel = Excel.decodeBytes(data);
        log('init worker', name: "importData");
        await excelRepository!.init(data);
        map["fileName"] = await excelRepository!.getFileName();
        map["Columns"] = await excelRepository!.getColumnCount();
        // map["data"] = await excelRepository!.getData();
        final excel = excelRepository!.excel;

        log('${excel?.sheets.length}', name: "excel");
        print(
            "importData Number of sheets:  ${await excelRepository!.getColumnCount()} ");
        // if (excel != null && excel.sheets.isNotEmpty) {
        //   map[fileName] = excel;
        // } else {
        //   log('Error: Unsupported file. Please try again.');
        // }
      } catch (e, st) {
        log('Error decoding Excel: $e', error: e, stackTrace: st);
      }
    }
    return map;
  }
}

/// Imports the Excel file using the file_picker package and offloads the decoding work.
///
/// Returns a map with the file name as the key and the decoded Excel object as the value.
